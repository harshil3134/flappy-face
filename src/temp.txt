import { useEffect, useRef } from "react";

function App() {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext("2d");

    canvas.width = 900;
    canvas.height = 600;

    let birdY = 250;
    let velocityY = 0;
    let x = 100;
    const gravity = 0.2;
    let jumpStrength = -6;

    const pipes = [];
    const pipeWidth = 60;
    const pipeGap = 180;
    const pipeSpeed = 2;
    let collisiondetection = false;
    let frameCount = 0;
    
    // Bird animation variables
    let birdFrame = 0;
    const birdSize = 40;
    
    // Create bird sprite frames using canvas drawing
    const createBirdFrames = () => {
      const frames = [];
      
      for (let i = 0; i < 3; i++) {
        const frameCanvas = document.createElement('canvas');
        frameCanvas.width = birdSize;
        frameCanvas.height = birdSize;
        const frameCtx = frameCanvas.getContext('2d');
        
        // Bird body (yellow circle)
        frameCtx.fillStyle = '#FFD700';
        frameCtx.beginPath();
        frameCtx.arc(birdSize/2, birdSize/2, 15, 0, Math.PI * 2);
        frameCtx.fill();
        
        // Bird eye
        frameCtx.fillStyle = 'black';
        frameCtx.beginPath();
        frameCtx.arc(birdSize/2 + 5, birdSize/2 - 3, 3, 0, Math.PI * 2);
        frameCtx.fill();
        
        // White eye highlight
        frameCtx.fillStyle = 'white';
        frameCtx.beginPath();
        frameCtx.arc(birdSize/2 + 6, birdSize/2 - 4, 1, 0, Math.PI * 2);
        frameCtx.fill();
        
        // Beak
        frameCtx.fillStyle = '#FF8C00';
        frameCtx.beginPath();
        frameCtx.moveTo(birdSize/2 + 12, birdSize/2);
        frameCtx.lineTo(birdSize/2 + 20, birdSize/2 - 2);
        frameCtx.lineTo(birdSize/2 + 20, birdSize/2 + 2);
        frameCtx.closePath();
        frameCtx.fill();
        
        // Wing (different positions for animation)
        frameCtx.fillStyle = '#FFB347';
        frameCtx.beginPath();
        
        if (i === 0) {
          // Wing up position
          frameCtx.ellipse(birdSize/2 - 5, birdSize/2 - 5, 8, 12, -0.3, 0, Math.PI * 2);
        } else if (i === 1) {
          // Wing middle position
          frameCtx.ellipse(birdSize/2 - 5, birdSize/2, 8, 12, 0, 0, Math.PI * 2);
        } else {
          // Wing down position
          frameCtx.ellipse(birdSize/2 - 5, birdSize/2 + 5, 8, 12, 0.3, 0, Math.PI * 2);
        }
        frameCtx.fill();
        
        // Wing details
        frameCtx.strokeStyle = '#FF8C00';
        frameCtx.lineWidth = 1;
        frameCtx.stroke();
        
        frames.push(frameCanvas);
      }
      
      return frames;
    };
    
    const birdFrames = createBirdFrames();

    function handleKeyDown(e) {
      if (e.code === "Space" || e.key === " ") {
        console.log("key detected", e);
        velocityY = jumpStrength;
      }
    }
    
    function generatepipe() {
      const pipe = {
        x: canvas.width,
        type: "",
        topHeight: 0,
        bottomY: 0,
        bottomHeight: 0,
      };

      const choice = ["top", "bottom", "combine"];
      const selected = choice[Math.floor(Math.random() * choice.length)];

      switch (selected) {
        case "top":
          pipe.type = "top";
          pipe.topHeight = Math.max(
            250,
            Math.floor(Math.random() * (canvas.height - 220))
          );
          break;
        case "bottom":
          pipe.type = "bottom";
          pipe.bottomHeight = Math.max(
            250,
            Math.floor(Math.random() * (canvas.height - 220))
          );
          break;
        case "combine":
          pipe.type = "both";
          pipe.topHeight = Math.max(
            250,
            Math.floor(Math.random() * (canvas.height - 220))
          );
          pipe.bottomHeight = canvas.height - pipe.topHeight - pipeGap;
          break;
      }
      pipes.push(pipe);
    }

    window.addEventListener("keydown", handleKeyDown);

    function draw() {
      frameCount++;
      
      // Clear the screen with sky blue background
      ctx.fillStyle = "#70c5ce";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Add some clouds for atmosphere
      ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
      ctx.beginPath();
      ctx.arc(150, 100, 25, 0, Math.PI * 2);
      ctx.arc(170, 100, 30, 0, Math.PI * 2);
      ctx.arc(190, 100, 25, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(600, 80, 20, 0, Math.PI * 2);
      ctx.arc(615, 80, 25, 0, Math.PI * 2);
      ctx.arc(630, 80, 20, 0, Math.PI * 2);
      ctx.fill();

      // Apply gravity
      velocityY += gravity;
      birdY += velocityY;

      // Ground and ceiling collision
      if (birdY > canvas.height - birdSize) {
        birdY = canvas.height - birdSize;
        velocityY = 0;
      }
      if (birdY < 0) {
        birdY = 0;
        velocityY = 0;
      }

      // Animate bird wings (change frame every 8 frames for smooth animation)
      if (frameCount % 8 === 0) {
        birdFrame = (birdFrame + 1) % 3;
      }
      
      // Draw animated bird
      ctx.save();
      
      // Rotate bird based on velocity for more realistic movement
      const rotation = Math.min(Math.max(velocityY * 0.1, -0.5), 0.5);
      ctx.translate(x + birdSize/2, birdY + birdSize/2);
      ctx.rotate(rotation);
      ctx.drawImage(birdFrames[birdFrame], -birdSize/2, -birdSize/2);
      
      ctx.restore();

      // Draw pipes with improved styling
      pipes.forEach((pipe) => {
        pipe.x -= pipeSpeed;
        
        // Pipe gradient
        const gradient = ctx.createLinearGradient(pipe.x, 0, pipe.x + pipeWidth, 0);
        gradient.addColorStop(0, '#4CAF50');
        gradient.addColorStop(0.5, '#45a049');
        gradient.addColorStop(1, '#3d8b40');
        
        ctx.fillStyle = gradient;
        
        if (pipe.type === "top") {
          ctx.fillRect(pipe.x, 0, pipeWidth, pipe.topHeight);
          // Pipe cap
          ctx.fillRect(pipe.x - 5, pipe.topHeight - 20, pipeWidth + 10, 20);
        } else if (pipe.type === "bottom") {
          ctx.fillRect(
            pipe.x,
            canvas.height - pipe.bottomHeight,
            pipeWidth,
            pipe.bottomHeight
          );
          // Pipe cap
          ctx.fillRect(pipe.x - 5, canvas.height - pipe.bottomHeight, pipeWidth + 10, 20);
        } else if (pipe.type === "both") {
          ctx.fillRect(pipe.x, 0, pipeWidth, pipe.topHeight);
          ctx.fillRect(
            pipe.x,
            canvas.height - pipe.bottomHeight,
            pipeWidth,
            pipe.bottomHeight
          );
          // Pipe caps
          ctx.fillRect(pipe.x - 5, pipe.topHeight - 20, pipeWidth + 10, 20);
          ctx.fillRect(pipe.x - 5, canvas.height - pipe.bottomHeight, pipeWidth + 10, 20);
        }
        
        // Pipe highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        if (pipe.type === "top") {
          ctx.fillRect(pipe.x, 0, 3, pipe.topHeight);
        } else if (pipe.type === "bottom") {
          ctx.fillRect(pipe.x, canvas.height - pipe.bottomHeight, 3, pipe.bottomHeight);
        } else if (pipe.type === "both") {
          ctx.fillRect(pipe.x, 0, 3, pipe.topHeight);
          ctx.fillRect(pipe.x, canvas.height - pipe.bottomHeight, 3, pipe.bottomHeight);
        }
      });

      // Generate new pipes
      if (frameCount % 120 == 0) {
        generatepipe();
      }
      
      // Remove pipes that are off screen
      for (let i = pipes.length - 1; i >= 0; i--) {
        if (pipes[i].x + pipeWidth < 0) {
          pipes.splice(i, 1);
        }
      }

      requestAnimationFrame(draw);
    }

    draw();

    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, []);

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-b from-blue-200 to-blue-400">
      <div className="mb-4">
        <h1 className="text-4xl font-bold text-white text-center drop-shadow-lg">
          üê¶ Flappy Bird
        </h1>
        <p className="text-white text-center mt-2 drop-shadow">
          Press SPACE to flap!
        </p>
      </div>
      
      <canvas
        ref={canvasRef}
        className="border-4 border-white rounded-lg shadow-2xl"
        width={900}
        height={600}
      />
      
      <div className="mt-4 text-white text-center">
        <p className="text-sm opacity-80">
          Navigate through the pipes without hitting them!
        </p>
      </div>
    </div>
  );
}

export default App;